an ordered collection also known as a sequence the user of this interface has precise control over where in the list each element is inserted the user can access elements by their integer index position in the list and search for elements in the list
unlike sets lists typically allow duplicate elements more formally lists typically allow pairs of elements e1 and e2 such that e1equalse2 and they typically allow multiple null elements if they allow null elements at all it is not inconceivable that someone might wish to implement a list that prohibits duplicates by throwing runtime exceptions when the user attempts to insert them but we expect this usage to be rare
the list interface places additional stipulations beyond those specified in the collection interface on the contracts of the iterator add remove equals and hashcode methods declarations for other inherited methods are also included here for convenience
the list interface provides four methods for positional indexed access to list elements lists like java arrays are zero based note that these operations may execute in time proportional to the index value for some implementations the linkedlist class for example thus iterating over the elements in a list is typically preferable to indexing through it if the caller does not know the implementation
the list interface provides a special iterator called a listiterator that allows element insertion and replacement and bidirectional access in addition to the normal operations that the iterator interface provides a method is provided to obtain a list iterator that starts at a specified position in the list
the list interface provides two methods to search for a specified object from a performance standpoint these methods should be used with caution in many implementations they will perform costly linear searches
the list interface provides two methods to efficiently insert and remove multiple elements at an arbitrary point in the list
note while it is permissible for lists to contain themselves as elements extreme caution is advised the equals and hashcode methods are no longer well defined on such a list
some list implementations have restrictions on the elements that they may contain for example some implementations prohibit null elements and some have restrictions on the types of their elements attempting to add an ineligible element throws an unchecked exception typically nullpointerexception or classcastexception attempting to query the presence of an ineligible element may throw an exception or it may simply return false some implementations will exhibit the former behavior and some will exhibit the latter more generally attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the list may throw an exception or it may succeed at the option of the implementation such exceptions are marked as optional in the specification for this interface
an object that maps keys to values a map cannot contain duplicate keys each key can map to at most one value
this interface takes the place of the dictionary class which was a totally abstract class rather than an interface
the map interface provides three collection views which allow a maps contents to be viewed as a set of keys collection of values or set of key-value mappings the order of a map is defined as the order in which the iterators on the maps collection views return their elements some map implementations like the treemap class make specific guarantees as to their order others like the hashmap class do not
note great care must be exercised if mutable objects are used as map keys the behavior of a map is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is a key in the map a special case of this prohibition is that it is not permissible for a map to contain itself as a key while it is permissible for a map to contain itself as a value extreme caution is advised the equals and hashcode methods are no longer well defined on such a map
all general-purpose map implementation classes should provide two standard constructors a void no arguments constructor which creates an empty map and a constructor with a single argument of type map which creates a new map with the same key-value mappings as its argument in effect the latter constructor allows the user to copy any map producing an equivalent map of the desired class there is no way to enforce this recommendation as interfaces cannot contain constructors but all of the general-purpose map implementations in the jdk comply
the destructive methods contained in this interface that is the methods that modify the map on which they operate are specified to throw unsupportedoperationexception if this map does not support the operation if this is the case these methods may but are not required to throw an unsupportedoperationexception if the invocation would have no effect on the map for example invoking the putallmap method on an unmodifiable map may but is not required to throw the exception if the map whose mappings are to be superimposed is empty
some map implementations have restrictions on the keys and values they may contain for example some implementations prohibit null keys and values and some have restrictions on the types of their keys attempting to insert an ineligible key or value throws an unchecked exception typically nullpointerexception or classcastexception attempting to query the presence of an ineligible key or value may throw an exception or it may simply return false some implementations will exhibit the former behavior and some will exhibit the latter more generally attempting an operation on an ineligible key or value whose completion would not result in the insertion of an ineligible element into the map may throw an exception or it may succeed at the option of the implementation such exceptions are marked as optional in the specification for this interface
many methods in collections framework interfaces are defined in terms of the equals method for example the specification for the containskeyobject key method says returns true if and only if this map contains a mapping for a key k such that keynull  knull  keyequalsk this specification should not be construed to imply that invoking mapcontainskey with a non-null argument key will cause keyequalsk to be invoked for any key k implementations are free to implement optimizations whereby the equals invocation is avoided for example by first comparing the hash codes of the two keys the objecthashcode specification guarantees that two objects with unequal hash codes cannot be equal more generally implementations of the various collections framework interfaces are free to take advantage of the specified behavior of underlying object methods wherever the implementor deems it appropriate
some map operations which perform recursive traversal of the map may fail with an exception for self-referential instances where the map directly or indirectly contains itself this includes the clone equals hashcode and tostring methods implementations may optionally handle the self-referential scenario however most current implementations do not do so